思路


为什么要做form-builder，目的是为了解决什么问题？
	解决传统开发中重复开发“表单”功能逻辑的问题
	
	方便从数据配置生成有功能，有逻辑的页面


fc，fb，f7分别都是什么
	fc是生成json配置文件的
	
	fb是根据配置文件，生成最终使用的表单的
	
	f7是一个开源框架，主要功能是使用同样的html代码，根据设备不同，自动切换显示和操作逻辑，以实现类似于原生应用体验为主要功能


fb1实现了什么功能？
	render
		渲染基本控件（textarea）、使用插件的控件（select2 -> multiselect）
		
		PC端使用bs作为基本样式框架，使用jQuery作为功能框架
		
		手机端使用f7作为基本样式和功能框架（Dom7，仿jquery接口和功能，实现不同）
		
		渲染时采用简单的label和组件一对一模式

	setValue
		赋值

	validate
		PC端使用jQuery.validate控件进行校验
		
		移动端简单实现了弹窗提示必填项

	eventBind
		事件联动，即对一个控件进行了操作，影响其他的控件，具体行为需要预先配置

	transRead
		将整表转换为只读模式

	transStream
		将整表转换为流式布局模式

	fc1
		按照容器区分双击复制和编辑事件
		
		拖拽或双击复制控件、拖拽位置插入，复制和编辑使用分支实现
		
		根据编辑项自动生成编辑的form，分为item（渲染用）和rule（校验用）
		
		针对特殊编辑项（如备选项）使用特殊渲染处理
		
		使用fb的render方法、使用fb的template进行渲染，所见即所得
		
		校验同名项并提示
		
		绑定联动事件，可以点击或输入name来实现选项输入
		
		每次复制和编辑表单项，会更新到form.data上（item.data）
		
		点击getJson可以获取到对应的json配置，并且可以双向转换，即可以载入已编辑json渲染页面再次进行修改
		
		点击打开或关闭两种模式：只读、流式，可叠加
		
		实际生成表单的预览


fb1优点：
	代码量少，基本线性逻辑，较为简单直接
	
	fc使用fb进行实时渲染，保证了所见即所得
	
	fc的操作指导思路是直觉式操作，即符合大数软件习惯，方便理解和记忆


fb1缺点：
	不同组件重复性高，耦合度高
	
	框架的组合模式并不能很“科学”很有层次很有逻辑的解决需求，加了许多补丁，造成逻辑混乱、修改困难、可读性差
	
	区分复制和移动（编辑）操作，代码复杂度高，冗余很多
	
	所谓模板文件并不能起到真正模板的作用，只简单提供了html模板
	
	f7端页面局限pc端思路，不美观不方便
	
	无法实现组件、容器积木化，不能解决自由配置多媒体组件（容器）的需求，耦合度高（重要的事儿说两遍）


原因：
	大家可以想一下，开发过程不符合基本项目开发流程


fb2为何要重构？重构完毕后，好处都是什么？
	耦合度过高，代码结构、逻辑不科学，已经到了无法解决复杂度更上一层楼的需求的时候
	
	重构完毕后：
		容器、组件解耦，组合更灵活，重复代码更少，逻辑更科学


fb2逻辑和结构：
	代码结构：
		fb-f7
			组件s
			容器s
			组件父类
			容器父类
			fb核心文件
			fb事件联动功能模块
			fb分组校验功能模块

	渲染顺序：
		f7-my-app
		// 获取jsonConf
			
			fb.core
				render
				// 开始渲染
					
					form
					// 渲染form层时，渲染下一层“容器”
						
						container (AS ctn)
						// 渲染“容器”层时，渲染下一层“组件”
							
							component (AS cp)
							// “组件”渲染
							// 组件渲染时，给自己所在的表单加上校验步骤
								
								cp.render()
								// 渲染，完毕后退出本层

						ctn.appendTo()
						// 来到容器层，将已选染的组件组装到自己内部
						// 其实就是建立个层级关系

					ctn.appendTo()
					// 再来到表层，组装
					// 至此，表单渲染完成，基本的校验也有了

				setGroupRules
				// 加分组校验

				setEventBinds
				// 绑定联动事件

				setFormValue
				// 整表赋初值
				// 这里会调用到每个组件自己的setValue方法

	这样设计的好处：
		得益于父类设计基本接口，基本步骤和调用的标准方法名称，子类去实现自己不同类型的不同方法，现在耦合度得以大幅降低，只要是在大逻辑上正确，组件可以和容器任意拼插组合
		
		逻辑分层明确，修改和读代码的时候，哪层的方法，就去该层找实现
		
		将流式布局，重新整合成逻辑上更科学的容器概念，实现需求

		表面看起来是dom元素并排，而且是死的，实际上是有个逻辑层级和结构来维护着一个tree，比如只读模式，看起来已经是个不可编辑的span了，但是实际上改变了值，只读的值也会跟着改变，最后是值驱动着页面显示，从入口赋值即可，而不用传统的选中、赋值、修改其他逻辑状态，也就是说，实现了modal -> view的单向绑定。


fb2对应json数据的含义，是否必填等属性


目前进度


TODO


